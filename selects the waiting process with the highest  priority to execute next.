def priority_scheduling(processes, burst_time, priority):
    n = len(processes)
    arrival_time = [0] * n  # All processes arrive at time 0

    # Combine process info for sorting
    proc_info = list(zip(processes, burst_time, priority))
    
    # Sort by priority (lower number = higher priority)
    proc_info.sort(key=lambda x: x[2])

    # Initialize Completion Time (CT), Turnaround Time (TAT), Waiting Time (WT)
    ct = [0] * n
    tat = [0] * n
    wt = [0] * n

    # Completion Time calculation
    ct[0] = proc_info[0][1]  # First process completes after its burst time
    for i in range(1, n):
        ct[i] = ct[i-1] + proc_info[i][1]

    # TAT and WT calculation
    for i in range(n):
        tat[i] = ct[i] - arrival_time[i]
        wt[i] = tat[i] - proc_info[i][1]

    # Display results
    print("Process\tBurst Time\tPriority\tCompletion Time\tTurnaround Time\tWaiting Time")
    for i in range(n):
        print(f"P{proc_info[i][0]}\t{proc_info[i][1]}\t\t{proc_info[i][2]}\t\t{ct[i]}\t\t{tat[i]}\t\t{wt[i]}")

    # Average TAT and WT
    avg_tat = sum(tat) / n
    avg_wt = sum(wt) / n
    print(f"\nAverage Turnaround Time: {avg_tat:.2f}")
    print(f"Average Waiting Time: {avg_wt:.2f}")


# Example usage
processes = [1, 2, 3, 4]
burst_time = [10, 1, 2, 1]
priority = [3, 1, 4, 2]  # Lower number = higher priority

priority_scheduling(processes, burst_time, priority)
