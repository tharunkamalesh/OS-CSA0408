def sjf(processes, burst_time):
    n = len(processes)
    arrival_time = [0] * n  # Assume all processes arrive at time 0

    # Combine processes and burst times for sorting
    proc_bt = list(zip(processes, burst_time))
    
    # Sort processes by burst time (SJF rule)
    proc_bt.sort(key=lambda x: x[1])

    # Initialize Completion Time (CT), Turnaround Time (TAT), Waiting Time (WT)
    ct = [0] * n
    tat = [0] * n
    wt = [0] * n

    # Calculate Completion Time
    ct[0] = proc_bt[0][1]  # First process completes after its burst time
    for i in range(1, n):
        ct[i] = ct[i-1] + proc_bt[i][1]

    # Calculate TAT and WT
    for i in range(n):
        tat[i] = ct[i] - arrival_time[i]
        wt[i] = tat[i] - proc_bt[i][1]

    # Display results
    print("Process\tBurst Time\tCompletion Time\tTurnaround Time\tWaiting Time")
    for i in range(n):
        print(f"P{proc_bt[i][0]}\t{proc_bt[i][1]}\t\t{ct[i]}\t\t{tat[i]}\t\t{wt[i]}")

    # Average TAT and WT
    avg_tat = sum(tat) / n
    avg_wt = sum(wt) / n
    print(f"\nAverage Turnaround Time: {avg_tat:.2f}")
    print(f"Average Waiting Time: {avg_wt:.2f}")


# Example usage
processes = [1, 2, 3, 4]
burst_time = [6, 8, 7, 3]

sjf(processes, burst_time)
