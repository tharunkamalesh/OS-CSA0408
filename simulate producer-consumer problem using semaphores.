import threading
import time
import random

# Buffer size
BUFFER_SIZE = 5
buffer = []

# Semaphores
empty = threading.Semaphore(BUFFER_SIZE)  # Count of empty slots
full = threading.Semaphore(0)             # Count of full slots
mutex = threading.Lock()                  # Mutual exclusion

def producer(producer_id, items_to_produce=10):
    for i in range(items_to_produce):
        item = f"Item-{producer_id}-{i}"
        empty.acquire()  # Wait if buffer is full
        mutex.acquire()  # Enter critical section

        buffer.append(item)
        print(f"Producer {producer_id} produced: {item} | Buffer: {buffer}")

        mutex.release()  # Exit critical section
        full.release()   # Signal that buffer has items

        time.sleep(random.uniform(0.1, 0.5))  # Simulate production time

def consumer(consumer_id, items_to_consume=10):
    for _ in range(items_to_consume):
        full.acquire()   # Wait if buffer is empty
        mutex.acquire()  # Enter critical section

        item = buffer.pop(0)
        print(f"Consumer {consumer_id} consumed: {item} | Buffer: {buffer}")

        mutex.release()  # Exit critical section
        empty.release()  # Signal that buffer has empty slot

        time.sleep(random.uniform(0.1, 0.5))  # Simulate consumption time

if __name__ == "__main__":
    # Create producer and consumer threads
    producers = [threading.Thread(target=producer, args=(i,)) for i in range(2)]
    consumers = [threading.Thread(target=consumer, args=(i,)) for i in range(2)]

    # Start threads
    for t in producers + consumers:
        t.start()

    # Wait for all threads to finish
    for t in producers + consumers:
        t.join()

    print("\nSimulation finished.")
