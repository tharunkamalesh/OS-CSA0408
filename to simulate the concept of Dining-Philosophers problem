import threading
import time
import random

N = 5  # Number of philosophers
thinking_time = (1, 3)  # Random thinking time range
eating_time = (1, 2)    # Random eating time range

# Chopsticks represented as locks
chopsticks = [threading.Lock() for _ in range(N)]

def philosopher(i):
    while True:
        # Thinking
        print(f"Philosopher {i} is thinking.")
        time.sleep(random.uniform(*thinking_time))

        # Hungry -> try to pick up chopsticks
        left = i
        right = (i + 1) % N

        # To avoid deadlock: pick lowest numbered chopstick first
        first, second = (left, right) if left < right else (right, left)

        with chopsticks[first]:
            with chopsticks[second]:
                # Eating
                print(f"Philosopher {i} starts eating.")
                time.sleep(random.uniform(*eating_time))
                print(f"Philosopher {i} finishes eating.")

if __name__ == "__main__":
    threads = []
    for i in range(N):
        t = threading.Thread(target=philosopher, args=(i,))
        threads.append(t)
        t.start()

    # Let philosophers run for a while
    time.sleep(15)
    print("Simulation ended.")
